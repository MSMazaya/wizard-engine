enum WaliArg {
	PATH,
	FD,
	VOID_POINTER,
	NUM
}

def EBADFD = HostResult.Value1(Values.box_i(LinuxConst.EBADFD));

class WaliCheck(fdmap: FileDescriptorMap, memory: Memory) {
	/*
	// NOTE: Range<Value> OK to be passed as syscall args?
	def func_M(name: string, sig: SigDecl, hfp: (C, Range<Value>) -> HostResult) -> this {
		module.closures[name] = ClosureEntry<C>(name, sig, closeOver<C, Range<Value>, HostResult>(_, hfp));
	}
	Nope does not work, unpacking tuple != unpacking range
	*/
	def Syscall(args_type: Array<WaliArg>, syscall_num: int, args: Range<Value>, syscall: (int, Range<Value>) -> HostResult) -> HostResult {
	    var final_args = Array<Value>.new(args.length);
	    for (i = 0; i < args_type.length; i++) {
		    var arg_value: Value;
		    match (args_type[i]) {
			    FD => {
				var sysfd = getFd(args[i]);
				if (sysfd < 0) return EBADFD;
				arg_value = Values.box(sysfd);
			    }
			    PATH => {
				var path = getPath(args[i]);
				if (path.reason != TrapReason.NONE) return path.toHostResultThrow();
				// TODO: How?
				arg_value = Values.box(Pointer.atContents(path.result));
			    }
			    VOID_POINTER => {
				var p = getRegion(args, i);
				i++;
				if (p.reason != TrapReason.NONE) return p.toHostResultThrow();
				// TODO: How?
				arg_value = Values.box(Pointer.atContents(p.result));
			    }
			    NUM => arg_value = args[i];
		    }
		    final_args[i] = arg_value;
	    }
	    // TODO: matching
	    return syscall(syscall_num, final_args);
	}
	def getFd(arg: Value) -> int {
		return fdmap.get(Values.unbox_i(arg));
	}
	def getPath(arg: Value) -> MaybeTrap<Range<byte>> {
		var ptr = Values.unbox_u(arg);
		return memory.range_o_32z(ptr, u32.!(LinuxConst.MAXPATHLEN));
	}
	def getRegion(args: Range<Value>, n: int) -> MaybeTrap<Range<byte>> {
		var ptr = Values.unbox_u(args[n]);
		var len = Values.unbox_u(args[n+1]);
		return memory.range_ol_32(ptr, len);
	}
	def fd_void_pointer: Array<WaliArg> = [WaliArg.FD, WaliArg.VOID_POINTER];
}
