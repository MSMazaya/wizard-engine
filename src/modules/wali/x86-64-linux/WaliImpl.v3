component WaliImpl {
	def X86_PAGE_SIZE = 4096u64;
	var mmap_pagelen = 0u64;
	var wasm_pagelen = 0u64;

	def passthrough<T>(num: int, args: T, fdmap: FileDescriptorMap, memory: Memory) -> HostResult {
		var r = Linux.syscall(num, args);
		return HostResult.Value1(Values.box_l(r.0));
	}
	def open(num: int, args: (Pointer, u32, u32), fdmap: FileDescriptorMap, memory: Memory) -> HostResult {
		var r = Linux.syscall(num, args);
		if (r.0 < 0) return HostResult.Value1(Values.box_l(r.0));
		var fd = fdmap.alloc();
		fdmap.set(fd, int.!(r.0));
		return HostResult.Value1(Values.box_l(fd));
	}
	def dup(num: int, args: i32, fdmap: FileDescriptorMap, memory: Memory) -> HostResult {
		var r = Linux.syscall(num, args);
		if (r.0 < 0) return HostResult.Value1(Values.box_l(r.0));
		var fd = fdmap.alloc();
		fdmap.set(fd, int.!(r.0));
		return HostResult.Value1(Values.box_l(fd));
	}
	// Parameterized args because this function is reused for dup3:
	//
	// dup3() is the same as dup2(), except that:
	// 1. It can force the close-on-exec flag to be set for the new file descriptor by specifying O_CLOEXEC in flags.
	// 2. If oldfd equals newfd, then dup3() fails with the error EINVAL.
	//
	// Thus, from WALI implementation point-of-view, the implementation is the same
	def dup2<T>(num: int, args: T, fdmap: FileDescriptorMap, memory: Memory) -> HostResult {
		var r = Linux.syscall(num, args);
		if (r.0 < 0) return HostResult.Value1(Values.box_l(r.0));
		var fd = fdmap.get_userfd(int.!(r.0));
		if (fd == -1) {
			fd = fdmap.alloc();
		} 
		fdmap.set(fd, int.!(r.0));
		return HostResult.Value1(Values.box_l(fd));
	}
	def close(num: int, args: i32, fdmap: FileDescriptorMap, memory: Memory) -> HostResult {
		var r = Linux.syscall(num, args);
		fdmap.free(args);
		return HostResult.Value1(Values.box_l(args));
	}
	def mmap(num: int, args: (Pointer, i32, i32, i32, i32, i64), fdmap: FileDescriptorMap, memory: Memory) -> HostResult {
		var top_addr = memory.getMemBase64() + memory.num_bytes;
		var new_args = (top_addr, args.1, args.2, args.3 | LinuxConst.MAP_FIXED, args.4, args.5);
		var r = Linux.syscall(num, args);
		if (r.0 != -1) {
			var pages_to_add = (u64.!(args.1) + X86_PAGE_SIZE - 1) / X86_PAGE_SIZE;
			memory.grow(u64.!(pages_to_add));
		} else {
			return HostResult.Value1(Values.box_l(r.0));
		}
		var mem_addr = top_addr - memory.getMemBase64();
		var mmap_addr = memory.getReadWriteAlias64(mem_addr, mem_addr + u64.!(args.1));
		var mmap_pointer = Pointer.atContents(mmap_addr);
		return HostResult.Value1(Values.box_l(long.view(0)));
	}
	def munmap(num: int, args: (Pointer, i32), fdmap: FileDescriptorMap, memory: Memory) -> HostResult {
		var pages_to_add = (u64.!(args.1) + X86_PAGE_SIZE - 1) / X86_PAGE_SIZE;
		var r = Linux.syscall(num, args);
		return HostResult.Value1(Values.box_l(r.0));
	}
}
